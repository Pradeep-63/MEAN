Q-Aggregation in mongodb
Ans:-An aggregation pipeline consists of one or more stages that process documents:
-Each stage performs an operation on the input documents. For example, a stage can filter documents, group documents, and calculate values.
-The documents that are output from a stage are passed to the next stage.
-An aggregation pipeline can return results for groups of documents. For example, return the total, average, maximum, and minimum values.
1.$match:-The $match aggregation stage in MongoDB is used to filter documents in a collection. It passes only those documents that match the specified conditions to the next stage in the aggregation pipeline. This stage is similar to the find operation but is used within the context of an aggregation pipeline.
Synatx:{$match: { <query> }}
example:1
db.users.aggregate([
{ $match: { status: "A" } }
])

Key Points
•  Optimization: Place $match as early as possible in the pipeline to reduce the number of documents processed in subsequent stages
•  Index Usage: When $match is at the beginning of the pipeline, it can take advantage of indexes, similar to find operations.
[
  { "_id": 1, "name": "Alice", "age": 30, "city": "New York" },
  { "_id": 2, "name": "Bob", "age": 25, "city": "San Francisco" },
  { "_id": 3, "name": "Charlie", "age": 35, "city": "New York" },
  { "_id": 4, "name": "Dave", "age": 28, "city": "Chicago" }
]

Example:2-To filter users who live in "New York":
ans-db.users.aggregate([
  {
    $match: { city: "New York" }
  }
]);
Example:3-To filter users who are older than 25 and live in "New York":
ans-db.users.aggregate([
  {
    $match: {
      city: "New York",
      age: { $gt: 25 }
    }
  }
]);
example:4-To filter users who live in either "New York" or "Chicago":
ans:-db.users.aggregate([
  {
    $match: {
      $or: [
        { city: "New York" },
        { city: "Chicago" }
      ]
    }
  }
]);
Q-products[
  { "_id": 1, "name": "Laptop", "tags": ["electronics", "computers"] },
  { "_id": 2, "name": "Phone", "tags": ["electronics", "mobile"] },
  { "_id": 3, "name": "Desk", "tags": ["furniture"] }
]
example-5:To filter products that have the tag "electronics":
ans:db.products.aggregate([
 {
  $match:{ 
    tags:"electronics"
  }
 }
])
Q-orders[
  {
    "_id": 1,
    "product": "Laptop",
    "customer": { "name": "Alice", "city": "New York" },
    "quantity": 1
  },
  {
    "_id": 2,
    "product": "Phone",
    "customer": { "name": "Bob", "city": "San Francisco" },
    "quantity": 2
  },
  {
    "_id": 3,
    "product": "Desk",
    "customer": { "name": "Charlie", "city": "New York" },
    "quantity": 1
  }
]
example-6:To filter orders made by customers who live in "New York":
ans:db.products.aggregate([{
  $match:{ "customer.city":"New York"}
}])
//group
2.$group:The $group stage in MongoDB's aggregation framework is used to group documents by a specified key and perform aggregate functions on the grouped data. This is particularly useful for summarizing and analyzing data.
Syntax
{
$group: {
_id: <expression>, // Group key
<field1>: { <accumulator1>: <expression1> },
...
}
}
Q-sales collection with following data
[
  { "_id": 1, "product": "Laptop", "amount": 1200, "quantity": 1 },
  { "_id": 2, "product": "Laptop", "amount": 1300, "quantity": 2 },
  { "_id": 3, "product": "Phone", "amount": 800, "quantity": 5 },
  { "_id": 4, "product": "Phone", "amount": 900, "quantity": 3 },
  { "_id": 5, "product": "Tablet", "amount": 600, "quantity": 1 }
]
example-1:To group the sales by product and calculate the total sales amount for each product:
db.sales.aggregate([{
 $group:{
  _id:"$product",
  totalSalesAmount:{$sum:"$amount"}
 }
}])
example-2:To calculate the total quantity and average amount for each product:
ans-db.products.aggregate([{
 $group:{
   _id:"$product",
   totalQuantity:{$sum:"$quantity"},
   avgAmount:{$avg:"$amount"}
 }
}])
example-3:To count the number of sales records for each product:
ans:- db.sales.aggregate([
  {
    $group: {
      _id: "$product",
      count: { $sum: 1 }
    }
  }
]);
//sort 
3.$sort:The $sort stage in MongoDB's aggregation pipeline is used to order the documents based on a specified field or fields. The sorting can be done in ascending (1) or descending (-1) order.
syntax:{
  $sort: { <field1>: <sortOrder1>, <field2>: <sortOrder2>, ... }
}
Q-products with following field
[
  { "_id": 1, "name": "Laptop", "price": 1200 },
  { "_id": 2, "name": "Phone", "price": 800 },
  { "_id": 3, "name": "Tablet", "price": 600 },
  { "_id": 4, "name": "Monitor", "price": 300 }
]
example-1:To sort the products by price in ascending order:
ans:- db.products.aggregate([{
 $sort:{
  price:1
 }
}])
example-2:To sort the products by price in descending order:
ans:-db.products.aggregate([
  {
    $sort: { price: -1 }
  }
]);
Q-sales [
  { "_id": 1, "product": "Laptop", "amount": 1200 },
  { "_id": 2, "product": "Laptop", "amount": 1300 },
  { "_id": 3, "product": "Phone", "amount": 800 },
  { "_id": 4, "product": "Phone", "amount": 900 },
  { "_id": 5, "product": "Tablet", "amount": 600 }
]
example-3:To group the sales by product, calculate the total sales amount for each product, and then sort the result by total sales amount in descending order:
ans:db.sales.aggregate([
  {
    $group: {
      _id: "$product",
      totalSalesAmount: { $sum: "$amount" }
    }
  },
  {
    $sort: { totalSalesAmount: -1 }
  }
]);
//limit
Q-limit:The $limit stage in MongoDB's aggregation pipeline is used to restrict the number of documents that pass through the pipeline to a specified number. This is useful when you only need a subset of the results, such as for pagination or to get the top N results.
syntax:{ $limit: <positive 64-bit integer> }
Q-products [
  { "_id": 1, "name": "Laptop", "price": 1200 },
  { "_id": 2, "name": "Phone", "price": 800 },
  { "_id": 3, "name": "Tablet", "price": 600 },
  { "_id": 4, "name": "Monitor", "price": 300 },
  { "_id": 5, "name": "Keyboard", "price": 50 }
]
example-1:To get the first 3 products:
ans-db.products.aggregate([{
 $limit:3
}])
example-2:Suppose you want to find products with a price greater than 500 and limit the result to 2 documents:
ans-db.users.find([{
  $match:{
  price:{$gt:500}
  }
},
{
 $limit:2
}
])
example-3:Suppose you want to sort the products by price in descending order and then limit the result to 3 documents:
ans-db.products.aggregate([
 {
  $sort:{
   price:-1
  }
 },
 {
 $limit:3
 }

])
//skip
Q-skip:The $skip stage in MongoDB's aggregation pipeline is used to skip a specified number of documents. This is useful for pagination or when you want to ignore a certain number of initial documents in the result set.
syntax:{
  $skip: <number>
}
Q-products:[
  { "_id": 1, "name": "Laptop", "price": 1200 },
  { "_id": 2, "name": "Phone", "price": 800 },
  { "_id": 3, "name": "Tablet", "price": 600 },
  { "_id": 4, "name": "Monitor", "price": 300 },
  { "_id": 5, "name": "Keyboard", "price": 50 }
]
example-1:To skip the first 2 products:
ans-db.products.aggregate([
  {
    $skip: 2
  }
]);
example-2:Suppose you want to find products with a price greater than 100, skip the first 2 documents, and limit the result to 2 documents:
ans-db.products.aggregate([
{
  $match:{price:{$gt:100}}
},
{
 $skip:2
},
{
$limit:2
}
])
Q-sales:[
  { "_id": 1, "product": "Laptop", "amount": 1200 },
  { "_id": 2, "product": "Laptop", "amount": 1300 },
  { "_id": 3, "product": "Phone", "amount": 800 },
  { "_id": 4, "product": "Phone", "amount": 900 },
  { "_id": 5, "product": "Tablet", "amount": 600 }
]
example:To group the sales by product, calculate the total sales amount for each product, sort by total sales amount in descending order, skip the first group, and limit the result to 1 group:
ans-db.sales.aggregate([
 {
  $group:{ 
   _id:"$product",
   totalSalesAmount:{$sum:"$amount"}
  }
 },
 {
  $sort:{totalSalesAmount:-1}
 },
 {
 $skip:1
 },
 {
 $limit:1
 }
])
//count 
Q:Count:The $count stage in MongoDB's aggregation pipeline is used to count the number of documents that are passed to it. The result is a single document that contains the count of the documents in the pipeline. This stage is often used at the end of a pipeline to determine the total number of documents that match the previous stages' criteria.
syntax:{
  $count: "<field>"
}
Q-products:[
  { "_id": 1, "name": "Laptop", "price": 1200 },
  { "_id": 2, "name": "Phone", "price": 800 },
  { "_id": 3, "name": "Tablet", "price": 600 },
  { "_id": 4, "name": "Monitor", "price": 300 },
  { "_id": 5, "name": "Keyboard", "price": 50 }
]
example-1:To count the total number of products:
ans:-db.products.aggregate([{
 $count:"totalProducts"
}])
example-2:Suppose you want to count the number of products with a price greater than 500:
ans:-db.products.aggregate([{
 $match:{price:{$gt:500}}
},
{
$count:"expensiveProducts"
}
]
)
example-3:Suppose you want to sort the products by price in descending order, skip the first 2 products, and then count the remaining products:
ans:-db.products.aggregate([{
 $sort:{price:-1}
},
{
 $skip:2
},
{
 $count:"remainingProducts"
}
])
//project
Q-$project:The $project stage in MongoDB's aggregation pipeline is used to include, exclude, or add new fields to documents. It shapes the documents that are passed to the next stage in the pipeline by specifying the fields to include or exclude.
syntax:
{
  $project: {
    <field1>: <expression1>,
    <field2>: <expression2>,
    ...
  }
}
Each <expression> can be a boolean (1 or 0) to include or exclude the field, or a more complex expression to transform the field.
Q-products:[
  { "_id": 1, "name": "Laptop", "price": 1200, "category": "Electronics" },
  { "_id": 2, "name": "Phone", "price": 800, "category": "Electronics" },
  { "_id": 3, "name": "Tablet", "price": 600, "category": "Electronics" },
  { "_id": 4, "name": "Monitor", "price": 300, "category": "Electronics" },
  { "_id": 5, "name": "Keyboard", "price": 50, "category": "Accessories" }
]
example-1:To include only the name and price fields:
ans-db.products.aggregate([{
     $project:{
      name:1,
      price:1
     }
}])
example-2:To exclude the _id field:
ans-db.products.aggregate([{
     $project:{
     _id:0
      name:1,
      price:1
     }
}])
//lookup
Q-lookup:-The $lookup stage in MongoDB's aggregation pipeline is used to perform a left outer join to another collection in the same database. This allows you to combine data from multiple collections into a single document.
syntax:
{
  $lookup: {
    from: "<foreignCollection>",
    localField: "<fieldFromInputDocuments>",
    foreignField: "<fieldFromForeignDocuments>",
    as: "<outputArrayField>"
  }
}
-from: The collection to join.
-localField: The field from the input documents.
-foreignField: The field from the documents in the from collection.
-as: The name of the new array field to add to the input documents.
Q-Suppose you have two collections: orders and customers.
order:[
  { "_id": 1, "product": "Laptop", "quantity": 2, "customerId": 1 },
  { "_id": 2, "product": "Phone", "quantity": 1, "customerId": 2 },
  { "_id": 3, "product": "Tablet", "quantity": 3, "customerId": 1 }
]
customer:[
  { "_id": 1, "name": "Alice" },
  { "_id": 2, "name": "Bob" }
]
example-1:To join the orders collection with the customers collection to add customer details to each order 
db.order.aggregate([
 {
  $lookup:{
   from:"customer",
   localField:"customerId"
   foreignField:"_id"
   as:"customerDetails"
  }
 }
])
 example-2: -Unwinding the Joined Array: The $lookup stage adds the joined documents as an array. To flatten the results, you can use the $unwind stage:
ans:- db.order.aggregate([
 {
  $lookup:{
   from:"customer",
   localField:"customerId"
   foreignField:"_id"
   as:"customerDetails"
  }
 },
 {
 $unwind:"customerDetails"
 }
])
Q-products:[
  { "_id": 1, "name": "Laptop", "price": 1200 },
  { "_id": 2, "name": "Phone", "price": 800 },
  { "_id": 3, "name": "Tablet", "price": 600 }
]
example-3:To join orders with both customers and products:
ans:db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customerId",
      foreignField: "_id",
      as: "customerDetails"
    }
  },
  {
    $unwind: "$customerDetails"
  },
  {
    $lookup: {
      from: "products",
      localField: "product",
      foreignField: "name",
      as: "productDetails"
    }
  },
  {
    $unwind: "$productDetails"
  }
]);
//unwind 
Q-unwind:The $unwind stage in MongoDB's aggregation framework is used to deconstruct an array field from the input documents to output a document for each element of the array. This is particularly useful when you need to work with individual elements of an array within documents.
Syntax
{
$unwind: {
path: <field path>,
includeArrayIndex: <string>, // Optional
preserveNullAndEmptyArrays: <boolean> // Optional
}
}
-path: The field path to the array field. This is required.
-includeArrayIndex: The name of a new field to hold the array index of the element. This is optional.
-preserveNullAndEmptyArrays: If true, outputs the document if the array is null, missing, or empty. This is optional.
Q-student:[
  { "_id": 1, "name": "Alice", "courses": ["Math", "Science", "English"] },
  { "_id": 2, "name": "Bob", "courses": ["History", "Math"] },
  { "_id": 3, "name": "Charlie", "courses": [] }
]
example:
db.students.aggregate([
  {
    $unwind: "$courses"
  }
]);
output:[
  { "_id": 1, "name": "Alice", "courses": "Math" },
  { "_id": 1, "name": "Alice", "courses": "Science" },
  { "_id": 1, "name": "Alice", "courses": "English" },
  { "_id": 2, "name": "Bob", "courses": "History" },
  { "_id": 2, "name": "Bob", "courses": "Math" }
]
db.students.aggregate([
{
  $unwind:{
   path:"$courses",
   includeArrayIndex:"courseIndex"
  }
}
])
output:[
  { "_id": 1, "name": "Alice", "courses": "Math", "courseIndex": 0 },
  { "_id": 1, "name": "Alice", "courses": "Science", "courseIndex": 1 },
  { "_id": 1, "name": "Alice", "courses": "English", "courseIndex": 2 },
  { "_id": 2, "name": "Bob", "courses": "History", "courseIndex": 0 },
  { "_id": 2, "name": "Bob", "courses": "Math", "courseIndex": 1 }
]
db.students.aggregate([
  {
    $unwind: {
      path: "$courses",
      preserveNullAndEmptyArrays: true
    }
  }
]);
op-[
  { "_id": 1, "name": "Alice", "courses": "Math" },
  { "_id": 1, "name": "Alice", "courses": "Science" },
  { "_id": 1, "name": "Alice", "courses": "English" },
  { "_id": 2, "name": "Bob", "courses": "History" },
  { "_id": 2, "name": "Bob", "courses": "Math" },
  { "_id": 3, "name": "Charlie" }  // Preserved despite empty 'courses' array
]

























 


